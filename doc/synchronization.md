# Synchronisation mechanisms

## Technical background

Mixer is an extension of an internal Ubisoft Animation Studio tool named VRtist. As such, it currently contains code related to VRtist, but this code is meant to be moved out of Mixer.

This section describes the high level operation principles of the Mixer addon that are common to VRtist and ID-level synchronization.

Each Mixer addon connects to a server named `broadcaster`, and joins a room. Mixer keeps an in-memory copy of Blender data that is relevant for synchronization. When a depsgraph update is detected, the in-memory copy is compared to the Blender data. Detected changes are encoded into update messages and are used to update the in-memory copy. The update messages are sent to the server that broadcasts them to the other room users. On reception, the Mixer addons update the Blender data and the in-memory copy.

The network communication uses TCP sockets to exchange messages that are generated by a custom encoder. All these mechanisms were developed with a strong focus on delivering functionalities as soon as possible and there is a lot of room for enhancement.

The synchronisation mechanism was originally developed for our VRtist software that include a Unity VR client. As a consequence, the data that are synchronised for VRtist are selected for their relevance to VRtist and the the synchronization "cooks" Blender data into VRtist related messages.

When it became important to have a full Blender synchronization independently of VRtist, a synchronization mechanism at the Blender ID level was developped. This mechanism is named _Experimental synchronisation_ in the UI and _Blender Full Protocol_ in the source code. As the Blender Full Protocol does not yet support all IDs, it currently coexists with the VRtist protocol.

A probable evolution is to move the VRtist protocol into a plugin, and this would make it possible to connect other DCCs by implementing other plugins.

## Blender ID-level synchronisation

The ID level synchronization is in `mixer/blender_data` and mainly in `proxy.py`. This file implement `Proxy` classes that can be loaded from Blender properties, serialized, then deserialized and saved into Blender properties on the receiving side.

These Proxy classes are meant to mirror Blender data storage in `bpy.data`. This included simple properties, structures, IDs, references to IDs in bpy.data, structures and colections of all these.

At the top level, a single `BpyBlendProxy` instance recursively mirrors most of `bpy.data`.

### Controlling items to synchronize

What is actually synchronized is "statically" controlled by filters defined in `filter.py` :

- `default_exclusions` controls excluded attributes for each Blender structure. This can be used to exclude properties that are used for internal use or that are just views into other properties.
- `safe_depsgraph_updates` and `safe_blenddata_collections` control the ID collections that are synchronized. More types and bpy.data collections are added to these items as more tests can be performed. When development is complete, both should be in sync and list most of bpy.data collections and types.

There is currently no way for the user to control what can be synchronized.

Subclasses of `Proxy` handles `bpy.data` synchronization in a very generic way, but type-specific adjustments are needed, for instance because factory methods for collection elements differ according to the element type. All these type-specific code is in `specifics.py`.

So adding items to synchronize should just be a matter of editing `filter.py` and `specifics.py`.

### The synchronization process

Changes are detected using a depsgraph modification handler, processed by `send_scene_data_to_server()`. The core of the ID-level synchronization is inside the `use_experimental_sync()` test, the rest being synchronization for the VRtist protocol.

We start by computing a difference between the cached BpyBlendProxy and the current Blender state. This difference is restricted to added or removed elements. Modified elements will be taken from the depsgraph update. Then the proxy is requested to update itself and compute the list of updated or removed ID proxies. The updated proxies are then serialized and sent. The serialization currently uses JSON (`json_codec.py`) and this is just a choice to deliver features quickly. At this point, each ID is sent as a whole and an addition mechanism should be implemented to compute a property-level difference, in order to send a minimal amount of data.

The messages are received by the server that broadcasts them to the users that are joined to the room. On reception, `build_data_update()` deserialises the `BpyIDProxy`, then calls `BpyBendProxy.update_one()` so that the global proxy updates itself and the corresponding `bpy.data` item, recursively updating all the sub-properties.

### Known restrictions

- A limited subset of bpy.data collections are synchronized (see `filter.py`), and synchronization of animation data is not available
- Undo redo is not supported and may break the synchronization

## VRtist/ID level synchronization coexistence

The Blender ID-level synchronisation is not yet complete, and some parts of the synchronisation are performed by the VRtist protocol (mostly `bpy.types.Mesh`), while other aspects of the synchronisation is partially duplicate in the two protocols (`bpy.types.Light` for instance). This is a transient situation and it should be solved by moving the VRtist related code into a plugin that uses data from the full Blender protocol.

An undesirable side effect is that the order of updates sent from both protocols has been carefully intermixed in `send_scene_data_to_server()` so both protocols can coexist.
